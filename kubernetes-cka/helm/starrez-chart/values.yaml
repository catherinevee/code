# -- General application settings
app:
  name: "starrez" # The name of the application, used for resource naming.
  image:
    repository: "catherinevee/starrez" # Docker image repository.
    tag: latest # Docker image tag. Consider using specific tags for production.
    pullPolicy: IfNotPresent # Image pull policy: Always, Never, IfNotPresent.

# -- Number of replica pods for the website.
# Best practice: Use a minimum of 2 for high availability.
replicaCount: 2

# -- Service configuration
service:
  type: ClusterIP # Service type: ClusterIP (internal), NodePort (external via node IP), LoadBalancer (external via cloud provider LB).
  port: 80 # Port on which the service will listen.
  targetPort: 8080 # Port on the container that the service will forward traffic to.
  # -- Annotations for the Service. Useful for cloud-specific configurations.
  annotations: {}
  #  service.beta.kubernetes.io/aws-load-balancer-internal: "true"

  # -- Ingress configuration for external access
ingress:
  enabled: true # Enable or disable Ingress. Set to false if you are using another method for external access.
  className: nginx # Ingress controller class (e.g., nginx, traefik).
  # -- Hostnames to expose the service on.
  # Best practice: Use a specific hostname for production.
  hosts:
  - host: "catherine.starrez.com" # Replace with your actual domain.
    paths:
    - path: /
      pathType: Prefix # Path matching type: Prefix, Exact, ImplementationSpecific.
  # -- TLS configuration for Ingress.
  # Requires a cert-manager or pre-existing secret with TLS certificates.
  tls:
    enabled: true
    secretName: starrez-tls # Name of the Kubernetes Secret containing TLS certificates.
    # -- Hosts for which the TLS secret applies. Must match a host in ingress.hosts.
    hosts:
    - catherine.starrez.com

# -- Resource limits and requests for the application pods.
# Best practice: Define appropriate limits and requests to ensure stable performance
# and avoid resource starvation or excessive resource consumption.
resources:
  requests:
    cpu: 100m # 100 millicores (0.1 CPU core)
    memory: 128Mi # 128 MiB
  limits:
    cpu: 300m # 300 millicores (0.3 CPU core)
    memory: 256Mi # 256 MiB

# -- Pod security context settings
# Best practice: Configure security context for enhanced security.
securityContext:
  runAsNonRoot: true # Ensures the container runs as a non-root user.
  runAsUser: 1001 # Specify a non-root user ID.
  fsGroup: 1001 # Specify the primary group ID for the pod's volumes.

# -- Container security context settings
containerSecurityContext:
  allowPrivilegeEscalation: false # Prevent processes in the container from gaining more privileges.
  readOnlyRootFilesystem: true # Mount the container's root filesystem as read-only.
  capabilities:
    drop:
    - ALL # Drop all capabilities to reduce the attack surface.

# -- Configuration for the ConfigMap.
# Use this for non-sensitive configuration data.
config:
  # Example configuration values.
  # These will be mounted as files or environment variables in the pod.
  WELCOME_MESSAGE: "Welcome!"
  API_ENDPOINT: "http://api.catherine.starrez.com:8080"
  DEBUG_MODE: "false"

# -- Configuration for the Secret.
# Use this for sensitive data like API keys, database credentials, etc.
# Best practice: Store sensitive data in a Secret and refer to it, do not hardcode in values.yaml.
# For production, consider using a secret management solution like HashiCorp Vault or Kubernetes external secrets.
secret:
  create: true # Set to false if you manage the secret outside of Helm.
  # Example sensitive values. Base64 encoded for demonstration purposes only.
  # In a real scenario, these would typically be managed by an external secret solution
  # or provided securely during deployment.
  # Use 'echo -n "your_value" | base64' to encode.
  DATABASE_URL: "YmIudmFsdWU=" # base64 encoded "db.value"
  API_KEY: "c2VjcmV0X2FwaV9rZXk=" # base64 encoded "secret_api_key"

# -- Node selector to schedule pods on specific nodes.
nodeSelector: {}
#  kubernetes.io/os: linux

# -- Tolerations for scheduling pods on tainted nodes.
tolerations: []
#  - key: "example-key"
#    operator: "Exists"
#    effect: "NoSchedule"

# -- Liveness and readiness probes for health checks.
# Best practice: Implement robust probes to ensure application health.
livenessProbe:
  httpGet:
    path: /healthz # Health check endpoint for liveness.
    port: 8080
  initialDelaySeconds: 10
  periodSeconds: 10
  timeoutSeconds: 5
  failureThreshold: 3

readinessProbe:
  httpGet:
    path: /ready # Health check endpoint for readiness.
    port: 8080
  initialDelaySeconds: 5
  periodSeconds: 5
  timeoutSeconds: 3
  failureThreshold: 2

# -- Autoscaling configuration (Horizontal Pod Autoscaler)
autoscaling:
  enabled: false # Set to true to enable HPA.
  minReplicas: 2
  maxReplicas: 5
  targetCPUUtilizationPercentage: 80 # Target CPU utilization for scaling.
  # targetMemoryUtilizationPercentage: 80 # Target memory utilization for scaling.

  # -- ServiceAccount configuration
serviceAccount:
  create: true # Specifies whether a ServiceAccount should be created.
  name: "" # The name of the ServiceAccount to use. If not set and create is true, a name is generated.

# -- Pod annotations (e.g., for Prometheus scraping)
podAnnotations: {}
#  prometheus.io/scrape: "true"
#  prometheus.io/port: "8080"

# -- Persistence configuration for data volumes (if needed)
# Not typically needed for a stateless website, but included for completeness.
persistence:
  enabled: false
  size: 8Gi
  storageClassName: standard # Or your specific StorageClass
  accessModes:
  - ReadWriteOnce
  mountPath: /app/data # Path inside the container where the volume will be mounted.
